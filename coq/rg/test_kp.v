Require Import Coq.Reals.Reals. Require Import Coq.Reals.Exp_prop. Require Import Coq.Lists.List. Require Import Coq.micromega.Lra. Require Import rg.polymer_types. Require Import rg.cluster_combinatorics. Import ListNotations. Open Scope R_scope.
Section RootedTree.
Context {P : Type} {PS : PolymerSystem P} {MS : MetricSystem P} {CS : ConnectivitySystem P} {SS : SummationSystem P} {DEq : DecidableEq P}.
Variable a : R. Hypothesis Ha_pos : a > 0.
Variable nbr_excluding : P -> list P -> list P.
Definition prod_overlap_excluding (p : P) (forb : list P) (f : P -> R) : R := fold_right Rmult 1 (map f (nbr_excluding p forb)).
Definition sum_overlap_excluding (p : P) (forb : list P) (f : P -> R) : R := fold_right Rplus 0 (map f (nbr_excluding p forb)).
Fixpoint rooted_sum (k : nat) (p : P) (forb : list P) : R := match k with | 0%nat => 0 | S k' => activity p * exp (a * size p) * prod_overlap_excluding p forb (fun q => 1 + rooted_sum k' q (p :: forb)) end.
Hypothesis activity_nonneg : forall p, 0 <= activity p.
Hypothesis size_nonneg : forall p, 0 <= size p.
Lemma one_plus_le_exp : forall x : R, 0 <= x -> 1 + x <= exp x. Proof. intros x Hx. apply exp_ineq1_le. Qed.
Lemma fold_right_Rmult_nonneg : forall (l : list P) (f : P -> R), (forall q, In q l -> 0 <= f q) -> 0 <= fold_right Rmult 1 (map f l). Proof. intros l f Hnonneg. induction l as [|x xs IH]; simpl. - lra. - apply Rmult_le_pos. + apply Hnonneg. left. reflexivity. + apply IH. intros q Hq. apply Hnonneg. right. exact Hq. Qed.
Lemma prod_le_exp_sum : forall (l : list P) (f : P -> R), (forall q, In q l -> 0 <= f q) -> fold_right Rmult 1 (map (fun q => 1 + f q) l) <= exp (fold_right Rplus 0 (map f l)). Proof. intros l f Hnonneg. induction l as [|x xs IH]; simpl. - rewrite exp_0. right. lra. - set (sx := fold_right Rplus 0 (map f xs)). assert (Hfx : 0 <= f x). { apply Hnonneg. left. reflexivity. } assert (IH_xs : fold_right Rmult 1 (map (fun q : P => 1 + f q) xs) <= exp sx). { apply IH. intros q Hq. apply Hnonneg. right. exact Hq. } assert (Hhead : 1 + f x <= exp (f x)). { apply one_plus_le_exp. exact Hfx. } eapply Rle_trans. + apply Rmult_le_compat; try lra. * apply fold_right_Rmult_nonneg. intros q Hq. assert (Hfq : 0 <= f q). { apply Hnonneg. right. exact Hq. } lra. * exact Hhead. * exact IH_xs. + rewrite <- exp_plus. right. ring. Qed.
Definition kp_condition_via_sum (a : R) : Prop := forall p, sum_overlap p (fun q => activity q * exp (a * size q)) <= a * size p.
Hypothesis sum_excluding_le_full : forall p forb f, (forall q, In q (nbr_excluding p forb) -> 0 <= f q) -> sum_overlap_excluding p forb f <= sum_overlap p f.
Lemma sum_list_R_mono : forall (l : list P) (f g : P -> R), (forall q, In q l -> f q <= g q) -> fold_right Rplus 0 (map f l) <= fold_right Rplus 0 (map g l). Proof. intros l f g Hle. induction l as [|x xs IH]; simpl. - right. reflexivity. - assert (Hlex : f x <= g x). { apply Hle. left. reflexivity. } assert (HIH : fold_right Rplus 0 (map f xs) <= fold_right Rplus 0 (map g xs)). { apply IH. intros q Hq. apply Hle. right. exact Hq. } lra. Qed.
Lemma prod_neighbors_le_exp_kp : forall p forb k, kp_condition_via_sum (2*a) -> (forall q, In q (nbr_excluding p forb) -> 0 <= rooted_sum k q (p::forb)) -> (forall q, In q (nbr_excluding p forb) -> rooted_sum k q (p::forb) <= activity q * exp (2 * a * size q)) -> prod_overlap_excluding p forb (fun q => 1 + rooted_sum k q (p::forb)) <= exp (2 * a * size p). Proof. intros p forb k Hkp Hnonneg Hle. unfold prod_overlap_excluding. set (L := nbr_excluding p forb). set (f := fun q => rooted_sum k q (p::forb)). assert (Hprod : fold_right Rmult 1 (map (fun q => 1 + f q) L) <= exp (fold_right Rplus 0 (map f L))). { apply prod_le_exp_sum. intros q Hq. unfold f. apply Hnonneg. exact Hq. } assert (Hsum : fold_right Rplus 0 (map f L) <= fold_right Rplus 0 (map (fun q => activity q * exp (2 * a * size q)) L)). { apply sum_list_R_mono. exact Hle. } eapply Rle_trans; [exact Hprod|]. apply exp_le. assert (HKPsum : fold_right Rplus 0 (map (fun q => activity q * exp (2 * a * size q)) L) <= 2 * a * size p). { unfold L. eapply Rle_trans. - apply sum_excluding_le_full. intros q Hq. assert (0 <= activity q) by apply activity_nonneg. assert (0 < exp (2 * a * size q)) by apply exp_pos. nra. - apply Hkp. } lra. Qed.
